<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Mathx Documentation: mathx::linsolv Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mathx Documentation
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Mathx is a software project that aims to solve computational mathematical problems.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00035.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mathx::linsolv Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0473301e2e258c5ba1ad058fa0e19135"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0473301e2e258c5ba1ad058fa0e19135"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a0473301e2e258c5ba1ad058fa0e19135">matmul</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;x, bool a_trans=false)</td></tr>
<tr class="memdesc:a0473301e2e258c5ba1ad058fa0e19135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix by a vector.  <a href="#a0473301e2e258c5ba1ad058fa0e19135">More...</a><br /></td></tr>
<tr class="separator:a0473301e2e258c5ba1ad058fa0e19135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647c3970ff4afe9ad63032b6d44fa5a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a647c3970ff4afe9ad63032b6d44fa5a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a647c3970ff4afe9ad63032b6d44fa5a2">mamtul</a> (<a class="el" href="a00018.html">array</a>&lt; double &gt; al, <a class="el" href="a00018.html">array</a>&lt; double &gt; am, <a class="el" href="a00018.html">array</a>&lt; double &gt;au, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a647c3970ff4afe9ad63032b6d44fa5a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a tri-diagonal matrix by a vector.  <a href="#a647c3970ff4afe9ad63032b6d44fa5a2">More...</a><br /></td></tr>
<tr class="separator:a647c3970ff4afe9ad63032b6d44fa5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18a18b9f8f6fd174b6505fcf33712b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af18a18b9f8f6fd174b6505fcf33712b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;B)</td></tr>
<tr class="memdesc:af18a18b9f8f6fd174b6505fcf33712b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices.  <a href="#af18a18b9f8f6fd174b6505fcf33712b5">More...</a><br /></td></tr>
<tr class="separator:af18a18b9f8f6fd174b6505fcf33712b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13d00937bf22422a58e5983f582203f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac13d00937bf22422a58e5983f582203f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#ac13d00937bf22422a58e5983f582203f">transpose</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac13d00937bf22422a58e5983f582203f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns transpose of a matrix.  <a href="#ac13d00937bf22422a58e5983f582203f">More...</a><br /></td></tr>
<tr class="separator:ac13d00937bf22422a58e5983f582203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22357ed3428d7d581f4d641a2d6ee69f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22357ed3428d7d581f4d641a2d6ee69f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a22357ed3428d7d581f4d641a2d6ee69f">mult_transpose</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a22357ed3428d7d581f4d641a2d6ee69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply a matrix by its transpose (A^T)A.  <a href="#a22357ed3428d7d581f4d641a2d6ee69f">More...</a><br /></td></tr>
<tr class="separator:a22357ed3428d7d581f4d641a2d6ee69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae68d89d62f31a211ede8a121d2ad91"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abae68d89d62f31a211ede8a121d2ad91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">back_substitution</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;U, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:abae68d89d62f31a211ede8a121d2ad91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform backwards substitution to solve Ux=b.  <a href="#abae68d89d62f31a211ede8a121d2ad91">More...</a><br /></td></tr>
<tr class="separator:abae68d89d62f31a211ede8a121d2ad91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70f07e05ed47bc1eedccc8d66221228"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae70f07e05ed47bc1eedccc8d66221228"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">forward_substitution</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;L, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b, bool isLU=false)</td></tr>
<tr class="memdesc:ae70f07e05ed47bc1eedccc8d66221228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform forward substitution to solve Lx=b.  <a href="#ae70f07e05ed47bc1eedccc8d66221228">More...</a><br /></td></tr>
<tr class="separator:ae70f07e05ed47bc1eedccc8d66221228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad471232f36ebf3e1ca0775a3e8439e78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad471232f36ebf3e1ca0775a3e8439e78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#ad471232f36ebf3e1ca0775a3e8439e78">lu</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b, int pstrategy=0)</td></tr>
<tr class="memdesc:ad471232f36ebf3e1ca0775a3e8439e78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a square matrix A into L and U.  <a href="#ad471232f36ebf3e1ca0775a3e8439e78">More...</a><br /></td></tr>
<tr class="separator:ad471232f36ebf3e1ca0775a3e8439e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497161a8a42f4a7d9f5555580f6ba02b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a497161a8a42f4a7d9f5555580f6ba02b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a497161a8a42f4a7d9f5555580f6ba02b">cholesky</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a497161a8a42f4a7d9f5555580f6ba02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Cholesky decomposition of a s.p.d matrix.  <a href="#a497161a8a42f4a7d9f5555580f6ba02b">More...</a><br /></td></tr>
<tr class="separator:a497161a8a42f4a7d9f5555580f6ba02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa02f46310ed4553e46c295c66532389"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa02f46310ed4553e46c295c66532389"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#aaa02f46310ed4553e46c295c66532389">is_spd</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; A)</td></tr>
<tr class="memdesc:aaa02f46310ed4553e46c295c66532389"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if matrix is s.p.d.  <a href="#aaa02f46310ed4553e46c295c66532389">More...</a><br /></td></tr>
<tr class="separator:aaa02f46310ed4553e46c295c66532389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3710b9ff0307e61d21b74753731052"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff3710b9ff0307e61d21b74753731052"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#aff3710b9ff0307e61d21b74753731052">qr_factorization_mgs</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aff3710b9ff0307e61d21b74753731052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose A into QR (where R = (Q^T)A) using MGS.  <a href="#aff3710b9ff0307e61d21b74753731052">More...</a><br /></td></tr>
<tr class="separator:aff3710b9ff0307e61d21b74753731052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d4abab4c380f5347bad7cc09fb574a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27d4abab4c380f5347bad7cc09fb574a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a27d4abab4c380f5347bad7cc09fb574a">jacobi</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;x0, double tol, int maxiter, bool debug=false)</td></tr>
<tr class="memdesc:a27d4abab4c380f5347bad7cc09fb574a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find solution to linear system using Jacobi Iteration.  <a href="#a27d4abab4c380f5347bad7cc09fb574a">More...</a><br /></td></tr>
<tr class="separator:a27d4abab4c380f5347bad7cc09fb574a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c4e3f8c81f7811d6d5671cdcce8be7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c4e3f8c81f7811d6d5671cdcce8be7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a40c4e3f8c81f7811d6d5671cdcce8be7">gauss_seidel</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;x0, double tol, int maxiter, bool debug=false)</td></tr>
<tr class="memdesc:a40c4e3f8c81f7811d6d5671cdcce8be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find solution of linear system using Gauss-Seidel.  <a href="#a40c4e3f8c81f7811d6d5671cdcce8be7">More...</a><br /></td></tr>
<tr class="separator:a40c4e3f8c81f7811d6d5671cdcce8be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f6fa2349ad393712b2b1d8cb37ac53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23f6fa2349ad393712b2b1d8cb37ac53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a23f6fa2349ad393712b2b1d8cb37ac53">cgm</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;x0, double tol, int maxiter)</td></tr>
<tr class="memdesc:a23f6fa2349ad393712b2b1d8cb37ac53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear system using Conjugate Gradient method.  <a href="#a23f6fa2349ad393712b2b1d8cb37ac53">More...</a><br /></td></tr>
<tr class="separator:a23f6fa2349ad393712b2b1d8cb37ac53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b2e85d9d2e8985d8ce4dbc718ef9f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15b2e85d9d2e8985d8ce4dbc718ef9f9"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T, <a class="el" href="a00018.html">array</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a15b2e85d9d2e8985d8ce4dbc718ef9f9">power_method</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;v0, double tol, int maxiter, bool debug=false)</td></tr>
<tr class="memdesc:a15b2e85d9d2e8985d8ce4dbc718ef9f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the power method to find the largest eigenvalue and corresponding eigenvector of a matrix.  <a href="#a15b2e85d9d2e8985d8ce4dbc718ef9f9">More...</a><br /></td></tr>
<tr class="separator:a15b2e85d9d2e8985d8ce4dbc718ef9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea05919c91a0aa3f80c57f639afebc6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aea05919c91a0aa3f80c57f639afebc6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#aea05919c91a0aa3f80c57f639afebc6f">shift</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, T alpha)</td></tr>
<tr class="memdesc:aea05919c91a0aa3f80c57f639afebc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift a matrix by alpha.  <a href="#aea05919c91a0aa3f80c57f639afebc6f">More...</a><br /></td></tr>
<tr class="separator:aea05919c91a0aa3f80c57f639afebc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41b6136a93cea27008e4f53859c6cd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af41b6136a93cea27008e4f53859c6cd5"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T, <a class="el" href="a00018.html">array</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#af41b6136a93cea27008e4f53859c6cd5">inverse_power_method</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;v0, double alpha, double tol, int maxiter, bool debug=false)</td></tr>
<tr class="memdesc:af41b6136a93cea27008e4f53859c6cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the inverse power method to find smallest eigenvalue and corresponding eigenvector.  <a href="#af41b6136a93cea27008e4f53859c6cd5">More...</a><br /></td></tr>
<tr class="separator:af41b6136a93cea27008e4f53859c6cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9152893cf3d71aff75b83b4b1e38fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b9152893cf3d71aff75b83b4b1e38fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a5b9152893cf3d71aff75b83b4b1e38fa">inverse</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a5b9152893cf3d71aff75b83b4b1e38fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a matrix.  <a href="#a5b9152893cf3d71aff75b83b4b1e38fa">More...</a><br /></td></tr>
<tr class="separator:a5b9152893cf3d71aff75b83b4b1e38fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4a2fef3e649aa80f86ced0303855fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c4a2fef3e649aa80f86ced0303855fb"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a8c4a2fef3e649aa80f86ced0303855fb">kappa</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, int norm_type=0)</td></tr>
<tr class="memdesc:a8c4a2fef3e649aa80f86ced0303855fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a lower bound of the condition number of a square matrix.  <a href="#a8c4a2fef3e649aa80f86ced0303855fb">More...</a><br /></td></tr>
<tr class="separator:a8c4a2fef3e649aa80f86ced0303855fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4dc645aac37dd5222fa04ebacfbe36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b4dc645aac37dd5222fa04ebacfbe36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a7b4dc645aac37dd5222fa04ebacfbe36">gaussian_elimination</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b, int pstrategy=0)</td></tr>
<tr class="memdesc:a7b4dc645aac37dd5222fa04ebacfbe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform Guassian elimination on a matrix given a solution vector.  <a href="#a7b4dc645aac37dd5222fa04ebacfbe36">More...</a><br /></td></tr>
<tr class="separator:a7b4dc645aac37dd5222fa04ebacfbe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9447fda76d500f569f3db423525b07d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9447fda76d500f569f3db423525b07d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">mathx::array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#ad9447fda76d500f569f3db423525b07d">solve</a> (<a class="el" href="a00018.html">array</a>&lt; T &gt; al, <a class="el" href="a00018.html">array</a>&lt; T &gt; am, <a class="el" href="a00018.html">array</a>&lt; T &gt; au, <a class="el" href="a00018.html">array</a>&lt; T &gt; b)</td></tr>
<tr class="memdesc:ad9447fda76d500f569f3db423525b07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a tri-diagonal system of equations.  <a href="#ad9447fda76d500f569f3db423525b07d">More...</a><br /></td></tr>
<tr class="separator:ad9447fda76d500f569f3db423525b07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42600f31ce0e9ae8a4c87f6f0dfd5e32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42600f31ce0e9ae8a4c87f6f0dfd5e32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a42600f31ce0e9ae8a4c87f6f0dfd5e32">solve</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a42600f31ce0e9ae8a4c87f6f0dfd5e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system Ax=b where A is s.p.d.  <a href="#a42600f31ce0e9ae8a4c87f6f0dfd5e32">More...</a><br /></td></tr>
<tr class="separator:a42600f31ce0e9ae8a4c87f6f0dfd5e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d6f44b03e6cbe816fcd6083b0425c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0d6f44b03e6cbe816fcd6083b0425c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#ac0d6f44b03e6cbe816fcd6083b0425c3">solve</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; A, <a class="el" href="a00018.html">array</a>&lt; T &gt; b, int strategy)</td></tr>
<tr class="memdesc:ac0d6f44b03e6cbe816fcd6083b0425c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system Ax=b using Gaussian Elimination.  <a href="#ac0d6f44b03e6cbe816fcd6083b0425c3">More...</a><br /></td></tr>
<tr class="separator:ac0d6f44b03e6cbe816fcd6083b0425c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ccf059c44803cdec306491f2b47a836"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ccf059c44803cdec306491f2b47a836"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a9ccf059c44803cdec306491f2b47a836">solve</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; b, <a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;LU, int strategy)</td></tr>
<tr class="memdesc:a9ccf059c44803cdec306491f2b47a836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the linear system Ax=b.  <a href="#a9ccf059c44803cdec306491f2b47a836">More...</a><br /></td></tr>
<tr class="separator:a9ccf059c44803cdec306491f2b47a836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728f21807bde3267735a147fd6592302"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a728f21807bde3267735a147fd6592302"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a728f21807bde3267735a147fd6592302">least_squares</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a728f21807bde3267735a147fd6592302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the Least Squares via Normal Equations.  <a href="#a728f21807bde3267735a147fd6592302">More...</a><br /></td></tr>
<tr class="separator:a728f21807bde3267735a147fd6592302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fd548666ffd114f564a9c682e5f5df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a21fd548666ffd114f564a9c682e5f5df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a00035.html#a21fd548666ffd114f564a9c682e5f5df">least_squares_QR</a> (<a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;A, <a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;b)</td></tr>
<tr class="memdesc:a21fd548666ffd114f564a9c682e5f5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the Least Squares via QR Factorization.  <a href="#a21fd548666ffd114f564a9c682e5f5df">More...</a><br /></td></tr>
<tr class="separator:a21fd548666ffd114f564a9c682e5f5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace is the workhorse of the package. The focus of this namespace is solving systems of linear equations. However, several utility methods where included in this namespace to simplify internal access.<br />
<br />
The code is ordered in the following sections</p><ol type="1">
<li>Utility Methods - Methods to perform matrix operations such as multiplication</li>
<li>Factorizations - Methods to factor matrices</li>
<li>Iterative Methods - Iterative methods for solving systems of linear equations</li>
<li>Matrix Util Methods - Methods used to get information such as the inverse of a matrix</li>
<li>Solve Wrappers - These are helper methods that wrap the meta-algorithms to solve linear systems in a single function call</li>
<li>Least Squares Wrappers - These are helper methods that wrap the meta-algorithms to solve least squares problems into a single function call <br />
<br />
 Now that we have covered what is in this namespace, let us have some discussion on the merits of the different approaches to solving linear systems. Beginning with direct methods such as Gaussian elimination and LU fractorization.<br />
<br />
Gaussian elimination is robust especially when combined with pivoting, however it has an asymptotic complexity of <img class="formulaInl" alt="$O(n^3)$" src="form_70.png"/>. If you are solving a generic system of equations with little restraint on the matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> and you only need to solve once then Gaussian elimination is a solid algorithm. However, if you are solving multiple equations with the same matrix, then LU factorization will allow you to speed up subsequent solutions after the intital decomposition. LU factorization also has an asymptotic complexity of <img class="formulaInl" alt="$O(n^3)$" src="form_70.png"/>.<br />
<br />
Direct methods work well on matrices that are small ( <img class="formulaInl" alt="$n&lt;10000$" src="form_71.png"/>), however as <img class="formulaInl" alt="$n$" src="form_72.png"/> grows larger the more round-off error accumulates, thus rendering the results useless. To overcome this issue of round-off error accumulation, you should use an iterative approach. This namespace contains three, Jacobi iteration, Gauss-Seidel iteration, and the Conjugate Gradient Method (CGM). All three methods require strictly positive definite matrices. CGM converges much quicker than either Jacobi or Gauss-Seidel. </li>
</ol>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0473301e2e258c5ba1ad058fa0e19135"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::matmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a_trans</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a matrix by a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">x</td><td>- input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b - an array&lt;T&gt; that is the product of the action of A on x </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a4">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                                                    {</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;      <span class="keywordflow">if</span>(a_trans){</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        array&lt;T&gt; b(A.cols(), 0);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; A.cols(); j++){</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; A.rows(); i++){</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;            b[j] += A[i][j] * x[i];</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;          }</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        }</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;        <span class="keywordflow">return</span> b;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;      } <span class="keywordflow">else</span> {</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        array&lt;T&gt; b(A.rows(), 0);</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; A.rows(); i++){</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; A.cols(); j++){</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;            b[i] += A[i][j] * x[j];</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;          }</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;        }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;        <span class="keywordflow">return</span> b;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      }</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a647c3970ff4afe9ad63032b6d44fa5a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::mamtul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>al</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; double &gt;&#160;</td>
          <td class="paramname"><em>au</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a tri-diagonal matrix by a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">x</td><td>- input vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>b - an array&lt;T&gt; that is the product of the action of A on x </dd></dl>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                                                                     {</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;      array&lt;T&gt; b(x.size(), 0);</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;      b[0] = am[0] * x[0] + au[0] * x[1];</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; x.size() - 1; i++){</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        b[i] = (al[i] * x[i - 1]) + (am[i] * x[i]) + (au[i] * x[i + 1]);</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      }</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      b[x.size() - 1] = al[x.size() - 1] * x[x.size() - 2] + am[x.size() - 1] * x[x.size() - 1];</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;      <span class="keywordflow">return</span> b;</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af18a18b9f8f6fd174b6505fcf33712b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">matrix</a>&lt;T&gt; mathx::linsolv::matmul </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">B</td><td>- input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>C - a matrix&lt;T&gt; that is the product of AB </dd></dl>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                                                {</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;      matrix&lt;T&gt; C(A.rows(), B.cols());</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; A.rows(); i++){</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; B.cols(); j++){</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; A.cols(); k++){</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;            C[i][j] += A[i][k] * B[k][j];</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;          }</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;        }</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      }</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;      <span class="keywordflow">return</span> C;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac13d00937bf22422a58e5983f582203f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">matrix</a>&lt;T&gt; mathx::linsolv::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns transpose of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A^T - a matrix&lt;T&gt; that is the transpose of the input matrix A </dd></dl>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;                                     {</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      matrix&lt;T&gt; B(A.cols(), A.rows());</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0 ; j &lt; A.cols(); j++){</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; A.rows(); i++){</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;          B[j][i] = A[i][j];</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;        }</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      }</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      <span class="keywordflow">return</span> B;</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a22357ed3428d7d581f4d641a2d6ee69f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">matrix</a>&lt;T&gt; mathx::linsolv::mult_transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply a matrix by its transpose (A^T)A. </p>
<p>Thus method uses the fact that <img class="formulaInl" alt="$A^TA$" src="form_31.png"/> is simply the product of the symmetric entries. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>B - a matrix&lt;T&gt; that is the product of A and its transpose </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a17">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;                                          {</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;      matrix&lt;T&gt; B(A.cols(),A.cols(), (T)0);</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; A.cols(); i++){</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; A.cols(); j++){</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; A.rows(); k++){</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;            B[i][j] += A[k][i]*A[k][j];</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;          }</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        }</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      }</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;      <span class="keywordflow">return</span> B;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abae68d89d62f31a211ede8a121d2ad91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::back_substitution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform backwards substitution to solve Ux=b. </p>
<p>Backwards substitution uses an upper traingular matrix to solve <img class="formulaInl" alt="$U\textbf{x}=\textbf{b}$" src="form_32.png"/>, where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[x_k=\frac{b_k-\sum_{j=k+1}^na_{kj}x_j}{a_{kk}}\quad@cite AscherGrief\]" src="form_88.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>U an upper triangular matrix </td></tr>
    <tr><td class="paramname">-</td><td>b a vector of values for the right-hand side of the equation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution of Ux=b </dd></dl>
<div class="fragment"><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;                                                         {</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;      <span class="comment">// Initialize solution vector</span></div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;      array&lt;T&gt; x(b.size(), 0);</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;      <span class="comment">// Back Substitution</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = b.size() - 1; k &gt;= 0; k--){</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;        x[k] = b[k];</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k+1; j &lt; U.cols(); j++)</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;          x[k] -= U[k][j] * x[j];</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;        x[k] /= U[k][k];</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;      }</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;      <span class="comment">// Return the solution</span></div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;      <span class="keywordflow">return</span> x;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;    };</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae70f07e05ed47bc1eedccc8d66221228"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::forward_substitution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLU</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform forward substitution to solve Lx=b. </p>
<p>Forward substitution uses a lower triangular matrix to solve <img class="formulaInl" alt="$L\textbf{x}=\textbf{b}$" src="form_34.png"/>, where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[x_k=\frac{b_k-\sum_{j=1}^{k-1}a_{kj}x_j}{a_{kk}}\quad@cite AscherGrief\]" src="form_89.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">-</td><td>L a lower triangular matrix </td></tr>
    <tr><td class="paramname">-</td><td>b a vector of values for the right-hand side of the equation </td></tr>
    <tr><td class="paramname">-</td><td>isLU a flag to interpret D as all ones </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution fo Lx=b </dd></dl>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                                                                               {</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;      <span class="comment">// Initialize solution vector</span></div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;      array&lt;T&gt; x(b.size(), 0);</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      x[0] = b[0] / (isLU ? 1 : L[0][0]);</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;      <span class="comment">// Forward Substitution</span></div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; b.size(); i++){</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;        x[i] = b[i];</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; i; j++)</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;          x[i] -= L[i][j] * x[j];</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;        x[i] /= (isLU ? 1 : L[i][i]);</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;      }</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;      <span class="comment">// Return the solution</span></div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      <span class="keywordflow">return</span> x;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad471232f36ebf3e1ca0775a3e8439e78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">matrix</a>&lt;T&gt; mathx::linsolv::lu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pstrategy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Factor a square matrix A into L and U. </p>
<p>The process of Gaussian elimination factors a matrix into <img class="formulaInl" alt="$L$" src="form_36.png"/> and <img class="formulaInl" alt="$U$" src="form_37.png"/>. This method returns that decomposition. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector (used in pivoting) </td></tr>
    <tr><td class="paramname">pstrategy</td><td>- flag declaring the pivoting strategy 0 = no pivoting 1 = partial pivoting 2 = scaled partial pivoting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>LU - a matrix&lt;T&gt; that is the LU decompostion of A </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a15">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;                                                              {</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;      matrix&lt;T&gt; LU(A.rows(), A.cols());</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;      LU = A;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;      <span class="keywordtype">int</span> m = A.rows();</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;      <span class="keywordtype">int</span> n = A.cols();</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; m - 1; k++){</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        <span class="keywordflow">if</span>(pstrategy &gt; 0){</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;          <span class="keywordtype">int</span> kpiv = pstrategy == 1 ? LU.find_pivot(k) : LU.find_scaled_pivot(k);</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;          LU.swap_row(k, kpiv);</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;          std::swap(b[k], b[kpiv]);</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;        }</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = k + 1; i &lt; m; i++){</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;          T l = LU[i][k] / LU[k][k];</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k + 1; j &lt; n; j++){</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;            LU[i][j] = LU[i][j] - l * LU[k][j];</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;          }</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;          LU[i][k] = l;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        }</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;      }</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;      <span class="keywordflow">return</span> LU;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a497161a8a42f4a7d9f5555580f6ba02b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mathx::linsolv::cholesky </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Cholesky decomposition of a s.p.d matrix. </p>
<p>Cholesky decomposition is defined as <img class="formulaInl" alt="$A=GG^{T}$" src="form_38.png"/> where <img class="formulaInl" alt="$G=LD^{1/2}$" src="form_39.png"/> <a class="el" href="a00042.html#CITEREF_AscherGrief">[1]</a> This method is destructive to A </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Runtime</td><td>Error if matrix is not symmetric </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- nothing as this method modifies A in place </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a7">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                               {</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      <span class="comment">// Check if A is symmetric</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="keywordflow">if</span>(!A.is_symmetric())</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Matrix not symmetric in Cholesky Decomposition&quot;</span>);</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      <span class="comment">// Perform decomposition into GG^T</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      <span class="keywordtype">int</span> n = A.rows();</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; n - 1; k++){</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        A[k][k] = std::sqrt(A[k][k]);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = k + 1; i &lt; n; i++)</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;          A[i][k] = A[i][k] / A[k][k];</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k + 1; j &lt; n; j++){</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = j; i &lt; n; i++){</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;            A[i][j] = A[i][j] - A[i][k] * A[j][k];</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;            <span class="comment">// If A is not s.p.d. A[i][j] = NaN</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;            <span class="keywordflow">if</span>(std::isnan(A[i][j])) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Matrix not positive definite in Cholesky Decomposition&quot;</span>);</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;          }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;        }</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;      }</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;      A[n - 1][n - 1] = std::sqrt(A[n - 1][n - 1]);</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;      <span class="comment">// Reflect across diagonal</span></div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; A.rows(); i++)</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = i; j &lt; A.cols(); j++)</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          A[i][j] = A[j][i];</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaa02f46310ed4553e46c295c66532389"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mathx::linsolv::is_spd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if matrix is s.p.d. </p>
<p>using Cholesky Decomposition</p>
<p>A matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> is s.p.d. if <img class="formulaInl" alt="$A\in R^{nxn}$" src="form_41.png"/> and <img class="formulaInl" alt="$A_{i,j}=A_{j,i}$" src="form_42.png"/> and all eigenvalues of <img class="formulaInl" alt="$A$" src="form_40.png"/> are positive. Computing eigenvalues is complex, however there is a simple test. If the matrix <img class="formulaInl" alt="$A$" src="form_40.png"/> has a Cholesky factorization it is s.p.d. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>is_spd - a boolean indicating if the input matrix is s.p.d. </dd></dl>
<div class="fragment"><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;                            {</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;      <span class="keywordflow">try</span>{</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;        <span class="comment">// cholesky() throws an exception</span></div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        <a class="code" href="a00035.html#a497161a8a42f4a7d9f5555580f6ba02b">cholesky</a>(A);</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;      } <span class="keywordflow">catch</span>(...){</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <span class="comment">// cholesky() threw an error</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;        <span class="comment">// A is not s.p.d</span></div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;      }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;    }</div><div class="ttc" id="a00035_html_a497161a8a42f4a7d9f5555580f6ba02b"><div class="ttname"><a href="a00035.html#a497161a8a42f4a7d9f5555580f6ba02b">mathx::linsolv::cholesky</a></div><div class="ttdeci">void cholesky(matrix&lt; T &gt; &amp;A)</div><div class="ttdoc">Perform Cholesky decomposition of a s.p.d matrix. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:228</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aff3710b9ff0307e61d21b74753731052"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">matrix</a>&lt;T&gt; mathx::linsolv::qr_factorization_mgs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decompose A into QR (where R = (Q^T)A) using MGS. </p>
<p>Though the classical Gram-Shmidt algorithm is elegant it is also numerically unstable for columns of <img class="formulaInl" alt="$A$" src="form_40.png"/> that are nearly linearly dependant <a class="el" href="a00042.html#CITEREF_AscherGrief">[1]</a> A simple fix is to use the already computed columns of <img class="formulaInl" alt="$Q$" src="form_43.png"/> to find the jth column. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>QR - a matrix&lt;T&gt; that is the QR factorization of the input matrix </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a14">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;                                                {</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;      <span class="keywordtype">int</span> n = A.rows();</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;      matrix&lt;T&gt; Q(n,n, (T) 0);</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; n; j++){</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;        <span class="comment">// Set the jth column of</span></div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="comment">// Q to the jth column of A</span></div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++){</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;          Q[i][j] = A[i][j];</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;        }</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; j; i++){</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;          <span class="comment">// r_i,j = equals the dot</span></div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;          <span class="comment">// product of the jth and</span></div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;          <span class="comment">// ith columns of Q</span></div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;          T rij = 0;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; n; k++){</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;            rij += Q[k][j] * Q[k][i];</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;          }</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;          <span class="comment">// q_j = q_j - r_i,j * q_i</span></div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; n; k++){</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;            Q[k][j] -= rij * Q[k][i];</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;          }</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;        }</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;        <span class="comment">// Normalize the jth column of Q</span></div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;        T rjj = 0;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++){</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;          rjj += Q[i][j] * Q[i][j];</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;        }</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;        rjj = std::sqrt(rjj);</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++){</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;          Q[i][j] /= rjj;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;        }</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;      }</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;      <span class="keywordflow">return</span> Q;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a27d4abab4c380f5347bad7cc09fb574a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find solution to linear system using Jacobi Iteration. </p>
<p>Jacobi iteration defines </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\textbf{x}_{k+1} = \textbf{x}_k + D^{-1}\textbf{r}_k\quad@cite AscherGrief\]" src="form_90.png"/>
</p>
<p> Jacobi iteration belongs to relaxation methods. As such Jacobi iteration will only converge for strictly diagonally dominant matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- a strictly diagonally dominant matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
    <tr><td class="paramname">x0</td><td>- initial guess </td></tr>
    <tr><td class="paramname">tol</td><td>- error tolerance </td></tr>
    <tr><td class="paramname">maxiter</td><td>- maximum number of iterations to perform </td></tr>
    <tr><td class="paramname">debug</td><td>(false) - flag to print debug info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution to Ax=b </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a8">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                                                                                                         {</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;      <span class="comment">// initialize variables;</span></div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      array&lt;T&gt; xkp1;</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;      array&lt;T&gt; xk = x0;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;      <span class="keywordtype">int</span> iter = 0;</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;      <span class="keywordtype">int</span> n = A.cols();</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;      <span class="keywordtype">double</span> error = tol * 10;</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;      <span class="comment">// Perform iterations until stopping</span></div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;      <span class="comment">// criteria are met</span></div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;      <span class="keywordflow">while</span>(iter &lt; maxiter &amp;&amp; error &gt; tol){</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        <span class="comment">// Compute x^(k+1)[i] for i in [0,n);</span></div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        xkp1 = b;</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++){</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; i; j++)</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;            xkp1[i] -= A[i][j] * xk[j];</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = i + 1; j &lt; n; j++)</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;            xkp1[i] -= A[i][j] * xk[j];</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;          xkp1[i] /= A[i][i];</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;        }</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;        <span class="comment">// Calculate error</span></div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;        error = <a class="code" href="a00041.html#a23885b3e034945b3e4354f113262bf74">vectors::norm</a>(xkp1 - xk);</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;        <span class="comment">// Assign new variables</span></div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;        xk = xkp1;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        iter++;</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;      }</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;      <span class="keywordflow">if</span>(debug) std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; iter &lt;&lt; std::endl;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;      <span class="keywordflow">return</span> xkp1;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    }</div><div class="ttc" id="a00041_html_a23885b3e034945b3e4354f113262bf74"><div class="ttname"><a href="a00041.html#a23885b3e034945b3e4354f113262bf74">mathx::vectors::norm</a></div><div class="ttdeci">T norm(array&lt; T &gt; v)</div><div class="ttdoc">Calculates the -norm of a vector. </div><div class="ttdef"><b>Definition:</b> vectors.hpp:51</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a40c4e3f8c81f7811d6d5671cdcce8be7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::gauss_seidel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find solution of linear system using Gauss-Seidel. </p>
<p>Gauss-Seidel iteration defines </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\textbf{x}_{k+1}=\textbf{x}_k+E^{-1}\textbf{r}_k\quad@cite AscherGrief\]" src="form_91.png"/>
</p>
<p> Gauss-Seidel iteration belongs to relaxation methods. As such Jacobi iteration will only converge for strictly diagonally dominant matrices. Gauss-Seidel converges at twice the rate of Jacobi. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- a strictly diagonally dominant matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
    <tr><td class="paramname">x0</td><td>- initial guess </td></tr>
    <tr><td class="paramname">tol</td><td>- error tolerance </td></tr>
    <tr><td class="paramname">maxiter</td><td>- maximum number of iterations to perform </td></tr>
    <tr><td class="paramname">debug</td><td>(false) - flag to print debug info </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution of Ax=b </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a9">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;                                                                                                               {</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;      <span class="comment">// initialize variables;</span></div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;      array&lt;T&gt; xkp1;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;      array&lt;T&gt; xk = x0;</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;      <span class="keywordtype">int</span> iter = 0;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;      <span class="keywordtype">int</span> n = A.cols();</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;      <span class="keywordtype">double</span> error = tol * 10;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;      <span class="comment">// Perform iterations until stopping</span></div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;      <span class="comment">// criteria are met</span></div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;      <span class="keywordflow">while</span>(iter &lt; maxiter &amp;&amp; error &gt; tol){</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;        <span class="comment">// Compute x^(k+1)[i] for i in [0,n);</span></div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        xkp1 = b;</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++){</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; i; j++)</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;            xkp1[i] -= A[i][j] * xkp1[j];</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = i + 1; j &lt; n; j++)</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;            xkp1[i] -= A[i][j] * xk[j];</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;          xkp1[i] /= A[i][i];</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;        }</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;        <span class="comment">// Calculate error</span></div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;        error = <a class="code" href="a00041.html#a23885b3e034945b3e4354f113262bf74">vectors::norm</a>(xkp1 - xk);</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        <span class="comment">// Assign new variables</span></div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        xk = xkp1;</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;        iter++;</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;      }</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;      <span class="keywordflow">if</span>(debug) std::cout &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;, &quot;</span> &lt;&lt; iter &lt;&lt; std::endl;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;      <span class="keywordflow">return</span> xkp1;</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;    }</div><div class="ttc" id="a00041_html_a23885b3e034945b3e4354f113262bf74"><div class="ttname"><a href="a00041.html#a23885b3e034945b3e4354f113262bf74">mathx::vectors::norm</a></div><div class="ttdeci">T norm(array&lt; T &gt; v)</div><div class="ttdoc">Calculates the -norm of a vector. </div><div class="ttdef"><b>Definition:</b> vectors.hpp:51</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23f6fa2349ad393712b2b1d8cb37ac53"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::cgm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve linear system using Conjugate Gradient method. </p>
<p>The Conjugate Gradient method (CGM) overcomes a weakness of stationary methods in that it uses information gathered throughout its iterations. CGM defines </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[\textbf{x}_{k+1}=\textbf{x}_k+\alpha\textbf{p}_k\quad@cite AscherGrief\]" src="form_92.png"/>
</p>
<p> Where the vector <img class="formulaInl" alt="$\textbf{p}_k$" src="form_47.png"/> is the search direction and the scalar <img class="formulaInl" alt="$\alpha$" src="form_48.png"/> is the step size <a class="el" href="a00042.html#CITEREF_AscherGrief">[1]</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- a strictly diagonally dominant matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
    <tr><td class="paramname">x0</td><td>- initial guess </td></tr>
    <tr><td class="paramname">tol</td><td>- error tolerance </td></tr>
    <tr><td class="paramname">maxiter</td><td>- maximum number of iterations to perform </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution of Ax=b </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a10">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;                                                                                  {</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;      <span class="comment">// Initialize x^(k+1) and x^(k)</span></div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;      array&lt;T&gt; xkp1;</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;      array&lt;T&gt; xk = x0;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;      <span class="comment">// Initialize r^(k+1) and r^(k)</span></div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;      array&lt;T&gt; rkp1;</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;      array&lt;T&gt; rk = b - <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(A,x0);</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;      <span class="comment">// Initialize p^(k+1) and p^(k)</span></div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;      array&lt;T&gt; pkp1;</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;      array&lt;T&gt; pk = rk;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      <span class="comment">// Initialize tolerance and delta</span></div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;      tol = std::pow(tol, 2);</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;      <span class="keywordtype">double</span> deltak = <a class="code" href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">vectors::dot_product</a>(rk, rk);</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;      <span class="keywordtype">double</span> deltakp1;</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;      <span class="comment">// Initialize b delta</span></div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;      <span class="keywordtype">double</span> bdelta = <a class="code" href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">vectors::dot_product</a>(b, b);</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;      <span class="keywordtype">int</span> iter = 0;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;      <span class="keywordtype">int</span> n = A.cols();</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;      <span class="keywordflow">while</span>(deltak &gt; tol * bdelta &amp;&amp; iter &lt; maxiter){</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;        array&lt;T&gt; sk = <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(A, pk);</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;        <span class="keywordtype">double</span> alphak = deltak / <a class="code" href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">vectors::dot_product</a>(pk,sk);</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;        xkp1 = xk;</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;        rkp1 = rk;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;        <span class="comment">// Iterate to find x^(k+1)[i]</span></div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;        <span class="comment">// and r^(k+1)[i]</span></div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++){</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;          xkp1[i] += alphak * pk[i];</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;          rkp1[i] -= alphak * sk[i];</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;        }</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        <span class="comment">// Find delta k+1 and p^(k+1)</span></div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        deltakp1 = <a class="code" href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">vectors::dot_product</a>(rkp1, rkp1);</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        pkp1 = rkp1;</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++)</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;          pkp1[i] += (deltakp1 / deltak) * pk[i];</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;        <span class="comment">// Assign new values</span></div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;        xk = xkp1;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        pk = pkp1;</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;        rk = rkp1;</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        deltak = deltakp1;</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;        iter++;</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;      }</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;      <span class="keywordflow">return</span> xkp1;</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    }</div><div class="ttc" id="a00041_html_a7b1750161d05430004a8b22ac7a4f664"><div class="ttname"><a href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">mathx::vectors::dot_product</a></div><div class="ttdeci">T dot_product(array&lt; T &gt; v, array&lt; T &gt; w)</div><div class="ttdoc">Calculates the dot procuct of two vectors. </div><div class="ttdef"><b>Definition:</b> vectors.hpp:20</div></div>
<div class="ttc" id="a00035_html_af18a18b9f8f6fd174b6505fcf33712b5"><div class="ttname"><a href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">mathx::linsolv::matmul</a></div><div class="ttdeci">matrix&lt; T &gt; matmul(matrix&lt; T &gt; &amp;A, matrix&lt; T &gt; &amp;B)</div><div class="ttdoc">Multiply two matrices. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:79</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15b2e85d9d2e8985d8ce4dbc718ef9f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T,<a class="el" href="a00018.html">array</a>&lt;T&gt; &gt; mathx::linsolv::power_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the power method to find the largest eigenvalue and corresponding eigenvector of a matrix. </p>
<p>The power method finds the largest eigenvalue and corresponding eigenvector via an iterative approach. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">v0</td><td>- initial guess </td></tr>
    <tr><td class="paramname">tol</td><td>- error tolerance </td></tr>
    <tr><td class="paramname">maxiter</td><td>- max iterations to perform </td></tr>
    <tr><td class="paramname">debug</td><td>- Print debug info (default=false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$\lambda,\textbf{v}$" src="form_53.png"/> - a pair&lt;T, array&lt;T&gt;&gt; that is the pair of the largest eigenvalue of <img class="formulaInl" alt="$A$" src="form_40.png"/> and its corresponding eigenvector </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a11">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;                                                                                                           {</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;      <span class="comment">// Initialize variables</span></div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;      array&lt;T&gt; vkm1 = v0;</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;      array&lt;T&gt; vk;</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;      T lambda = 0;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;      T lambdakm1 = 10;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;      <span class="keywordtype">int</span> iter = 0;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;      <span class="keywordtype">double</span> error = 10 * tol;</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;      <span class="keywordflow">if</span>(debug) std::cout &lt;&lt; <span class="stringliteral">&quot;Iterations, Error, n&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;      <span class="comment">// Moving the matmul outside</span></div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;      <span class="comment">// the loop improves performance</span></div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;      <span class="comment">// and overcomes an issue of</span></div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;      <span class="comment">// overflow when n and iter are large</span></div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;      array&lt;T&gt; v = <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(A, vkm1);</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;      <span class="keywordflow">while</span>(iter++ &lt; maxiter &amp;&amp; error &gt; tol){</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        <span class="comment">// Normalize v and assing to vk;</span></div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        vk = <a class="code" href="a00041.html#a67d14188d316905d2c129a2eed926de6">vectors::normalize</a>(v);</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        <span class="comment">// Calculate lambda_k</span></div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        lambda = <a class="code" href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">vectors::dot_product</a>(vk, v);</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;        <span class="comment">// Calculate error</span></div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        error = std::abs(lambda - lambdakm1);</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        <span class="keywordflow">if</span>(debug) std::cout &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; error &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; A.cols() &lt;&lt; std::endl;</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        <span class="comment">// Reinitialize values for</span></div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        <span class="comment">// the next iteration</span></div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;        v = <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(A, vk);</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;        lambdakm1 = lambda;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;        vkm1 = v;</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;      }</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;      <span class="keywordflow">return</span> std::make_pair(lambda, vk);</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;    }</div><div class="ttc" id="a00041_html_a7b1750161d05430004a8b22ac7a4f664"><div class="ttname"><a href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">mathx::vectors::dot_product</a></div><div class="ttdeci">T dot_product(array&lt; T &gt; v, array&lt; T &gt; w)</div><div class="ttdoc">Calculates the dot procuct of two vectors. </div><div class="ttdef"><b>Definition:</b> vectors.hpp:20</div></div>
<div class="ttc" id="a00035_html_af18a18b9f8f6fd174b6505fcf33712b5"><div class="ttname"><a href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">mathx::linsolv::matmul</a></div><div class="ttdeci">matrix&lt; T &gt; matmul(matrix&lt; T &gt; &amp;A, matrix&lt; T &gt; &amp;B)</div><div class="ttdoc">Multiply two matrices. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:79</div></div>
<div class="ttc" id="a00041_html_a67d14188d316905d2c129a2eed926de6"><div class="ttname"><a href="a00041.html#a67d14188d316905d2c129a2eed926de6">mathx::vectors::normalize</a></div><div class="ttdeci">array&lt; T &gt; normalize(array&lt; T &gt; v)</div><div class="ttdoc">Normalizes a vector. </div><div class="ttdef"><b>Definition:</b> vectors.hpp:92</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aea05919c91a0aa3f80c57f639afebc6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">matrix</a>&lt;T&gt; mathx::linsolv::shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift a matrix by alpha. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- matrix to shift </td></tr>
    <tr><td class="paramname">alpha</td><td>- alpha </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A - a matrix&lt;T&gt; shifted by <img class="formulaInl" alt="$\alpha$" src="form_48.png"/> </dd></dl>
<div class="fragment"><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;                                          {</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;      matrix&lt;T&gt; shifted = A;</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; shifted.rows(); i++)</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;        shifted[i][i] -= alpha;</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;      <span class="keywordflow">return</span> shifted;</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af41b6136a93cea27008e4f53859c6cd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;T, <a class="el" href="a00018.html">array</a>&lt;T&gt; &gt; mathx::linsolv::inverse_power_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use the inverse power method to find smallest eigenvalue and corresponding eigenvector. </p>
<p>The power method finds the smallest eigenvalue and corresponding eigenvector via an iterative approach. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">v0</td><td>- intital guess </td></tr>
    <tr><td class="paramname">alpha</td><td>- shift value </td></tr>
    <tr><td class="paramname">tol</td><td>- error tolerance </td></tr>
    <tr><td class="paramname">maxiter</td><td>- max iterations to perform </td></tr>
    <tr><td class="paramname">debug</td><td>- Print debug info (default=false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$\lambda,\textbf{v}$" src="form_53.png"/> - a pair&lt;T, array&lt;T&gt;&gt; that is the pair of the smallest eigenvalue of <img class="formulaInl" alt="$A$" src="form_40.png"/> and its corresponding eigenvector </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a12">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;                                                                                                                                  {</div><div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;      <span class="comment">// Initialize variables</span></div><div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;      array&lt;T&gt; vkm1 = v0;</div><div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;      array&lt;T&gt; vk;</div><div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;      T lambda = 0;</div><div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;      T lambdakm1 = 10;</div><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;      <span class="keywordtype">double</span> error = 10 * tol;</div><div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;      <span class="keywordtype">int</span> iter = 0;</div><div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;</div><div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;      <span class="comment">// Shift A by alpha</span></div><div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;      A = <a class="code" href="a00035.html#aea05919c91a0aa3f80c57f639afebc6f">shift</a>(A, alpha);</div><div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;</div><div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;      <span class="comment">// Factor A* into L and U</span></div><div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;      matrix&lt;T&gt; LU = <a class="code" href="a00035.html#ad471232f36ebf3e1ca0775a3e8439e78">lu</a>(A, vkm1, 0);</div><div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;</div><div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;      <span class="keywordflow">if</span>(debug) std::cout &lt;&lt; <span class="stringliteral">&quot;Iterations, Error, n&quot;</span> &lt;&lt; std::endl;</div><div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;      <span class="keywordflow">while</span>(iter++ &lt; maxiter &amp;&amp; error &gt; tol){</div><div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;        <span class="comment">// Solve Shifted * v = vkm1</span></div><div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;        array&lt;T&gt; b = <a class="code" href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">forward_substitution</a>(LU, vkm1, <span class="keyword">true</span>);</div><div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;        array&lt;T&gt; v = <a class="code" href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">back_substitution</a>(LU, b);</div><div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;</div><div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;        <span class="comment">// Normalize v and assing to vk;</span></div><div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;        vk = <a class="code" href="a00041.html#a67d14188d316905d2c129a2eed926de6">vectors::normalize</a>(v);</div><div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;</div><div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;        <span class="comment">// Calculate lambda_k</span></div><div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;        lambda = <a class="code" href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">vectors::dot_product</a>(vk, <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(A, vk));</div><div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;</div><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        <span class="comment">// Calculate error</span></div><div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        error = std::abs(lambda - lambdakm1);</div><div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;</div><div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;        <span class="keywordflow">if</span>(debug) std::cout &lt;&lt; iter &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; error &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; A.cols() &lt;&lt; std::endl;</div><div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;</div><div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;        <span class="comment">// Reinitialize values for</span></div><div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;        <span class="comment">// the next iteration</span></div><div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;        lambdakm1 = lambda;</div><div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;        vkm1 = v;</div><div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;      }</div><div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div><div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;      <span class="keywordflow">return</span> std::make_pair(lambda, vk);</div><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;    }</div><div class="ttc" id="a00035_html_aea05919c91a0aa3f80c57f639afebc6f"><div class="ttname"><a href="a00035.html#aea05919c91a0aa3f80c57f639afebc6f">mathx::linsolv::shift</a></div><div class="ttdeci">matrix&lt; T &gt; shift(matrix&lt; T &gt; &amp;A, T alpha)</div><div class="ttdoc">Shift a matrix by alpha. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:550</div></div>
<div class="ttc" id="a00035_html_ad471232f36ebf3e1ca0775a3e8439e78"><div class="ttname"><a href="a00035.html#ad471232f36ebf3e1ca0775a3e8439e78">mathx::linsolv::lu</a></div><div class="ttdeci">matrix&lt; T &gt; lu(matrix&lt; T &gt; &amp;A, array&lt; T &gt; &amp;b, int pstrategy=0)</div><div class="ttdoc">Factor a square matrix A into L and U. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:196</div></div>
<div class="ttc" id="a00035_html_abae68d89d62f31a211ede8a121d2ad91"><div class="ttname"><a href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">mathx::linsolv::back_substitution</a></div><div class="ttdeci">array&lt; T &gt; back_substitution(matrix&lt; T &gt; &amp;U, array&lt; T &gt; &amp;b)</div><div class="ttdoc">Perform backwards substitution to solve Ux=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:137</div></div>
<div class="ttc" id="a00041_html_a7b1750161d05430004a8b22ac7a4f664"><div class="ttname"><a href="a00041.html#a7b1750161d05430004a8b22ac7a4f664">mathx::vectors::dot_product</a></div><div class="ttdeci">T dot_product(array&lt; T &gt; v, array&lt; T &gt; w)</div><div class="ttdoc">Calculates the dot procuct of two vectors. </div><div class="ttdef"><b>Definition:</b> vectors.hpp:20</div></div>
<div class="ttc" id="a00035_html_af18a18b9f8f6fd174b6505fcf33712b5"><div class="ttname"><a href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">mathx::linsolv::matmul</a></div><div class="ttdeci">matrix&lt; T &gt; matmul(matrix&lt; T &gt; &amp;A, matrix&lt; T &gt; &amp;B)</div><div class="ttdoc">Multiply two matrices. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:79</div></div>
<div class="ttc" id="a00035_html_ae70f07e05ed47bc1eedccc8d66221228"><div class="ttname"><a href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">mathx::linsolv::forward_substitution</a></div><div class="ttdeci">array&lt; T &gt; forward_substitution(matrix&lt; T &gt; &amp;L, array&lt; T &gt; &amp;b, bool isLU=false)</div><div class="ttdoc">Perform forward substitution to solve Lx=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:161</div></div>
<div class="ttc" id="a00041_html_a67d14188d316905d2c129a2eed926de6"><div class="ttname"><a href="a00041.html#a67d14188d316905d2c129a2eed926de6">mathx::vectors::normalize</a></div><div class="ttdeci">array&lt; T &gt; normalize(array&lt; T &gt; v)</div><div class="ttdoc">Normalizes a vector. </div><div class="ttdef"><b>Definition:</b> vectors.hpp:92</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b9152893cf3d71aff75b83b4b1e38fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00022.html">matrix</a>&lt;T&gt; mathx::linsolv::inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the inverse of a matrix. </p>
<p>This method computes the inverse by factoring <img class="formulaInl" alt="$A$" src="form_40.png"/> into <img class="formulaInl" alt="$L$" src="form_36.png"/> and <img class="formulaInl" alt="$U$" src="form_37.png"/>. Where <img class="formulaInl" alt="$L$" src="form_36.png"/> and <img class="formulaInl" alt="$U$" src="form_37.png"/> are strictly lower and upper triangular, respectively. The resulting decomposition is used to solve each one-spot vector where the <img class="formulaInl" alt="$k^{th}$" src="form_49.png"/> solution is the <img class="formulaInl" alt="$k^{th}$" src="form_49.png"/> column of <img class="formulaInl" alt="$A^{-1}$" src="form_50.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- matrix to compute inverse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><img class="formulaInl" alt="$A^{-1}$" src="form_50.png"/> - a matrix&lt;T&gt; that is the inverse of the input matrix </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a13">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;                                   {</div><div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;      array&lt;T&gt; onespot(A.cols(), 0);</div><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;</div><div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      <span class="comment">// Decompose A into L &amp; U</span></div><div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;      <span class="comment">// Passing one-spot as placeholder</span></div><div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;      <span class="comment">// as lu() is expecting a b for</span></div><div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;      <span class="comment">// pivoting</span></div><div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;      matrix&lt;T&gt; LU = <a class="code" href="a00035.html#ad471232f36ebf3e1ca0775a3e8439e78">lu</a>(A, onespot);</div><div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;</div><div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;      <span class="comment">// Calculate inverse of A</span></div><div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;      matrix&lt;T&gt; Ainv(A.rows(), A.cols());</div><div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;</div><div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      <span class="comment">// Use LU to solve for each one-spot</span></div><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; A.cols(); k++){</div><div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;        onespot = array&lt;T&gt;(A.cols(), 0);</div><div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;        onespot[k] = 1;</div><div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;        array&lt;T&gt; y = <a class="code" href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">forward_substitution</a>(A, onespot, <span class="keyword">true</span>);</div><div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;        array&lt;T&gt; x = <a class="code" href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">back_substitution</a>(A,y);</div><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div><div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;        <span class="comment">// kth solution is kth column</span></div><div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;        <span class="comment">// of the inverse</span></div><div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; A.cols(); i++)</div><div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;          Ainv[i][k] = x[i];</div><div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;      }</div><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;</div><div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;      <span class="keywordflow">return</span> Ainv;</div><div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;    }</div><div class="ttc" id="a00035_html_ad471232f36ebf3e1ca0775a3e8439e78"><div class="ttname"><a href="a00035.html#ad471232f36ebf3e1ca0775a3e8439e78">mathx::linsolv::lu</a></div><div class="ttdeci">matrix&lt; T &gt; lu(matrix&lt; T &gt; &amp;A, array&lt; T &gt; &amp;b, int pstrategy=0)</div><div class="ttdoc">Factor a square matrix A into L and U. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:196</div></div>
<div class="ttc" id="a00035_html_abae68d89d62f31a211ede8a121d2ad91"><div class="ttname"><a href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">mathx::linsolv::back_substitution</a></div><div class="ttdeci">array&lt; T &gt; back_substitution(matrix&lt; T &gt; &amp;U, array&lt; T &gt; &amp;b)</div><div class="ttdoc">Perform backwards substitution to solve Ux=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:137</div></div>
<div class="ttc" id="a00035_html_ae70f07e05ed47bc1eedccc8d66221228"><div class="ttname"><a href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">mathx::linsolv::forward_substitution</a></div><div class="ttdeci">array&lt; T &gt; forward_substitution(matrix&lt; T &gt; &amp;L, array&lt; T &gt; &amp;b, bool isLU=false)</div><div class="ttdoc">Perform forward substitution to solve Lx=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:161</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8c4a2fef3e649aa80f86ced0303855fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double mathx::linsolv::kappa </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>norm_type</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a lower bound of the condition number of a square matrix. </p>
<p>The condition number of a matrix is defined as <img class="formulaInl" alt="$||A||\cdot||A^{-1}||$" src="form_51.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">norm_type</td><td>- 0 -&gt; one norm; 1 -&gt; infinity norm </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>k - the approximation of <img class="formulaInl" alt="$k(A)$" src="form_54.png"/> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a5">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;                                               {</div><div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;      <span class="comment">// Find the inverse of A</span></div><div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;      matrix&lt;T&gt; Ainv = <a class="code" href="a00035.html#a5b9152893cf3d71aff75b83b4b1e38fa">inverse</a>(A);</div><div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;      <span class="comment">// Return the condition number</span></div><div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;      <span class="comment">// k(A) = ||A||*||A^-1||</span></div><div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;      <span class="keywordflow">switch</span>(norm_type){</div><div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;        <span class="keywordflow">case</span> 0:</div><div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;        <span class="keywordflow">return</span> A.one_norm() * Ainv.one_norm();</div><div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;        <span class="keywordflow">case</span> 1:</div><div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;        <span class="keywordflow">default</span>:</div><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;        <span class="keywordflow">return</span> A.infinity_norm() * Ainv.infinity_norm();</div><div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;      }</div><div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;    }</div><div class="ttc" id="a00035_html_a5b9152893cf3d71aff75b83b4b1e38fa"><div class="ttname"><a href="a00035.html#a5b9152893cf3d71aff75b83b4b1e38fa">mathx::linsolv::inverse</a></div><div class="ttdeci">matrix&lt; T &gt; inverse(matrix&lt; T &gt; &amp;A)</div><div class="ttdoc">Computes the inverse of a matrix. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:619</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7b4dc645aac37dd5222fa04ebacfbe36"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mathx::linsolv::gaussian_elimination </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pstrategy</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform Guassian elimination on a matrix given a solution vector. </p>
<p>Gaussian elimination uses elementry row opperations to reduce a given matrix into upper triangular form <a class="el" href="a00042.html#CITEREF_AscherGrief">[1]</a> This method is destructive to A and b. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- the input matrix </td></tr>
    <tr><td class="paramname">b</td><td>- the solution vector </td></tr>
    <tr><td class="paramname">pstrategy</td><td>- flag declaring the pivoting strategy 0 = no pivoting 1 = partial pivoting 2 = scaled partial pivoting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>- nothing as A and b are changed in place </dd></dl>
<div class="fragment"><div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;                                                                           {</div><div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; A.rows() - 1; k++){</div><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;        <span class="keywordflow">if</span>(pstrategy &gt; 0){</div><div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;          <span class="keywordtype">int</span> kpiv = pstrategy == 1 ? A.find_pivot(k) : A.find_scaled_pivot(k);</div><div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;          A.swap_row(k, kpiv);</div><div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;          std::swap(b[k], b[kpiv]);</div><div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;        }</div><div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;</div><div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = k + 1; i &lt; A.rows(); i++){</div><div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;          T l = A[i][k] / A[k][k];</div><div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;          <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = k + 1; j &lt; A.rows(); j++){</div><div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;            T a_kj = A[i][j] - l * A[k][j];</div><div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;            A[i][j] = a_kj;</div><div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;          }</div><div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;          b[i] = b[i] - l * b[k];</div><div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;        }</div><div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;      }</div><div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad9447fda76d500f569f3db423525b07d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">mathx::array</a>&lt;T&gt; mathx::linsolv::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>al</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>am</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>au</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a tri-diagonal system of equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">al</td><td>- lower diagonal </td></tr>
    <tr><td class="paramname">am</td><td>- main diagonal </td></tr>
    <tr><td class="paramname">au</td><td>- upper diagonal </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution to Ax=b where A is tri-diagonal </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00008.html#a6">linsolv.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;                                                                          {</div><div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;      <span class="comment">// Set n</span></div><div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;      <span class="keywordtype">int</span> n = b.size() - 1;</div><div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;</div><div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;      <span class="comment">// Factor first row</span></div><div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;      au[0] /= am[0];</div><div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;      b[0] /= am[0];</div><div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;</div><div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;      <span class="comment">// Factor interior rows</span></div><div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; n; i++){</div><div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;        au[i] /= am[i] - al[i] * au[i - 1];</div><div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;        b[i] = (b[i] - al[i] * b[i - 1]) / (am[i] - al[i] * au[i - 1]);</div><div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;      }</div><div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;</div><div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;      <span class="comment">// Factor last row</span></div><div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;      b[n] = (b[n] - al[n] * b[n - 1]) / (am[n] - al[n] * au[n - 1]);</div><div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;</div><div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;      <span class="comment">// Solve</span></div><div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;      <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = n; i &gt;= 0; i--){</div><div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;        b[i] -= au[i] * b[i + 1];</div><div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;      }</div><div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;</div><div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;      <span class="keywordflow">return</span> b;</div><div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a42600f31ce0e9ae8a4c87f6f0dfd5e32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the linear system Ax=b where A is s.p.d. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution to Ax=b where A is s.p.d. </dd></dl>
<div class="fragment"><div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;                                             {</div><div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;      <a class="code" href="a00035.html#a497161a8a42f4a7d9f5555580f6ba02b">cholesky</a>(A);</div><div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;      array&lt;T&gt; y = <a class="code" href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">forward_substitution</a>(A, b);</div><div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">back_substitution</a>(A, y);</div><div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;    }</div><div class="ttc" id="a00035_html_abae68d89d62f31a211ede8a121d2ad91"><div class="ttname"><a href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">mathx::linsolv::back_substitution</a></div><div class="ttdeci">array&lt; T &gt; back_substitution(matrix&lt; T &gt; &amp;U, array&lt; T &gt; &amp;b)</div><div class="ttdoc">Perform backwards substitution to solve Ux=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:137</div></div>
<div class="ttc" id="a00035_html_a497161a8a42f4a7d9f5555580f6ba02b"><div class="ttname"><a href="a00035.html#a497161a8a42f4a7d9f5555580f6ba02b">mathx::linsolv::cholesky</a></div><div class="ttdeci">void cholesky(matrix&lt; T &gt; &amp;A)</div><div class="ttdoc">Perform Cholesky decomposition of a s.p.d matrix. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:228</div></div>
<div class="ttc" id="a00035_html_ae70f07e05ed47bc1eedccc8d66221228"><div class="ttname"><a href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">mathx::linsolv::forward_substitution</a></div><div class="ttdeci">array&lt; T &gt; forward_substitution(matrix&lt; T &gt; &amp;L, array&lt; T &gt; &amp;b, bool isLU=false)</div><div class="ttdoc">Perform forward substitution to solve Lx=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:161</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac0d6f44b03e6cbe816fcd6083b0425c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the linear system Ax=b using Gaussian Elimination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
    <tr><td class="paramname">strategy</td><td>- flag for the method used to solve linear system 0 = GE no pivoting+ BS 1 = GE partial pivoting + BS 2 = GE scaled partial pivoting + BS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution to Ax=b </dd></dl>
<div class="fragment"><div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;                                                         {</div><div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;      <a class="code" href="a00035.html#a7b4dc645aac37dd5222fa04ebacfbe36">gaussian_elimination</a>(A, b, strategy);</div><div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">back_substitution</a>(A, b);</div><div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;    }</div><div class="ttc" id="a00035_html_a7b4dc645aac37dd5222fa04ebacfbe36"><div class="ttname"><a href="a00035.html#a7b4dc645aac37dd5222fa04ebacfbe36">mathx::linsolv::gaussian_elimination</a></div><div class="ttdeci">void gaussian_elimination(matrix&lt; T &gt; &amp;A, array&lt; T &gt; &amp;b, int pstrategy=0)</div><div class="ttdoc">Perform Guassian elimination on a matrix given a solution vector. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:685</div></div>
<div class="ttc" id="a00035_html_abae68d89d62f31a211ede8a121d2ad91"><div class="ttname"><a href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">mathx::linsolv::back_substitution</a></div><div class="ttdeci">array&lt; T &gt; back_substitution(matrix&lt; T &gt; &amp;U, array&lt; T &gt; &amp;b)</div><div class="ttdoc">Perform backwards substitution to solve Ux=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:137</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9ccf059c44803cdec306491f2b47a836"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the linear system Ax=b. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
    <tr><td class="paramname">LU</td><td>- a reference to store the LU factorization for later use </td></tr>
    <tr><td class="paramname">strategy</td><td>- flag for the method used to solve linear system 0 = LU no pivoting + FS &amp; BS 1 = LU partial pivoting + FS &amp; BS 2 = LU scaled pivoting + FS &amp; BS </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution to Ax=b </dd></dl>
<div class="fragment"><div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;                                                                         {</div><div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;      LU = <a class="code" href="a00035.html#ad471232f36ebf3e1ca0775a3e8439e78">lu</a>(A, b, strategy);</div><div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;      array&lt;T&gt; y = <a class="code" href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">forward_substitution</a>(LU, b, <span class="keyword">true</span>);</div><div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">back_substitution</a>(LU, y);</div><div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    }</div><div class="ttc" id="a00035_html_ad471232f36ebf3e1ca0775a3e8439e78"><div class="ttname"><a href="a00035.html#ad471232f36ebf3e1ca0775a3e8439e78">mathx::linsolv::lu</a></div><div class="ttdeci">matrix&lt; T &gt; lu(matrix&lt; T &gt; &amp;A, array&lt; T &gt; &amp;b, int pstrategy=0)</div><div class="ttdoc">Factor a square matrix A into L and U. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:196</div></div>
<div class="ttc" id="a00035_html_abae68d89d62f31a211ede8a121d2ad91"><div class="ttname"><a href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">mathx::linsolv::back_substitution</a></div><div class="ttdeci">array&lt; T &gt; back_substitution(matrix&lt; T &gt; &amp;U, array&lt; T &gt; &amp;b)</div><div class="ttdoc">Perform backwards substitution to solve Ux=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:137</div></div>
<div class="ttc" id="a00035_html_ae70f07e05ed47bc1eedccc8d66221228"><div class="ttname"><a href="a00035.html#ae70f07e05ed47bc1eedccc8d66221228">mathx::linsolv::forward_substitution</a></div><div class="ttdeci">array&lt; T &gt; forward_substitution(matrix&lt; T &gt; &amp;L, array&lt; T &gt; &amp;b, bool isLU=false)</div><div class="ttdoc">Perform forward substitution to solve Lx=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:161</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a728f21807bde3267735a147fd6592302"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::least_squares </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the Least Squares via Normal Equations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution to the least squares problem </dd></dl>
<div class="fragment"><div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;                                                     {</div><div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;      <span class="comment">// Compute (A^T)A</span></div><div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;      matrix&lt;T&gt; B = <a class="code" href="a00035.html#a22357ed3428d7d581f4d641a2d6ee69f">mult_transpose</a>(A);</div><div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;</div><div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;      <span class="comment">// Compute (A^T)b</span></div><div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;      array&lt;T&gt; y = <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(A, b, <span class="keyword">true</span>);</div><div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;</div><div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;      <span class="comment">// Use cholesky factorization to solve</span></div><div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="a00035.html#a9ccf059c44803cdec306491f2b47a836">solve</a>(B, y);</div><div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    }</div><div class="ttc" id="a00035_html_a22357ed3428d7d581f4d641a2d6ee69f"><div class="ttname"><a href="a00035.html#a22357ed3428d7d581f4d641a2d6ee69f">mathx::linsolv::mult_transpose</a></div><div class="ttdeci">matrix&lt; T &gt; mult_transpose(matrix&lt; T &gt; &amp;A)</div><div class="ttdoc">Multiply a matrix by its transpose (A^T)A. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:116</div></div>
<div class="ttc" id="a00035_html_af18a18b9f8f6fd174b6505fcf33712b5"><div class="ttname"><a href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">mathx::linsolv::matmul</a></div><div class="ttdeci">matrix&lt; T &gt; matmul(matrix&lt; T &gt; &amp;A, matrix&lt; T &gt; &amp;B)</div><div class="ttdoc">Multiply two matrices. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:79</div></div>
<div class="ttc" id="a00035_html_a9ccf059c44803cdec306491f2b47a836"><div class="ttname"><a href="a00035.html#a9ccf059c44803cdec306491f2b47a836">mathx::linsolv::solve</a></div><div class="ttdeci">array&lt; T &gt; solve(matrix&lt; T &gt; &amp;A, array&lt; T &gt; b, matrix&lt; T &gt; &amp;LU, int strategy)</div><div class="ttdoc">Solve the linear system Ax=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:785</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a21fd548666ffd114f564a9c682e5f5df"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00018.html">array</a>&lt;T&gt; mathx::linsolv::least_squares_QR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00022.html">matrix</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00018.html">array</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve the Least Squares via QR Factorization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>- input matrix </td></tr>
    <tr><td class="paramname">b</td><td>- solution vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x - an array&lt;T&gt; that is the solution to Ax=b </dd></dl>
<div class="fragment"><div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;                                                        {</div><div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;      <span class="comment">// Factorize A into Q</span></div><div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;      matrix&lt;T&gt; Q = <a class="code" href="a00035.html#aff3710b9ff0307e61d21b74753731052">qr_factorization_mgs</a>(A);</div><div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;</div><div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;      <span class="comment">// Compute Q transpose</span></div><div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;      matrix&lt;T&gt; qT = <a class="code" href="a00035.html#ac13d00937bf22422a58e5983f582203f">transpose</a>(Q);</div><div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;</div><div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;      <span class="comment">// Compute R from Q transpose x A</span></div><div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;      matrix&lt;T&gt; R = <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(qT, A);</div><div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;</div><div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;      <span class="comment">// Compute C from Q transpose x b</span></div><div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;      array&lt;T&gt; c = <a class="code" href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">matmul</a>(qT, b);</div><div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;</div><div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;      <span class="comment">// Use back substitution to solve Rx = c</span></div><div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;      <span class="keywordflow">return</span> <a class="code" href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">back_substitution</a>(R,c);</div><div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;    }</div><div class="ttc" id="a00035_html_ac13d00937bf22422a58e5983f582203f"><div class="ttname"><a href="a00035.html#ac13d00937bf22422a58e5983f582203f">mathx::linsolv::transpose</a></div><div class="ttdeci">matrix&lt; T &gt; transpose(matrix&lt; T &gt; &amp;A)</div><div class="ttdoc">Returns transpose of a matrix. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:98</div></div>
<div class="ttc" id="a00035_html_abae68d89d62f31a211ede8a121d2ad91"><div class="ttname"><a href="a00035.html#abae68d89d62f31a211ede8a121d2ad91">mathx::linsolv::back_substitution</a></div><div class="ttdeci">array&lt; T &gt; back_substitution(matrix&lt; T &gt; &amp;U, array&lt; T &gt; &amp;b)</div><div class="ttdoc">Perform backwards substitution to solve Ux=b. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:137</div></div>
<div class="ttc" id="a00035_html_af18a18b9f8f6fd174b6505fcf33712b5"><div class="ttname"><a href="a00035.html#af18a18b9f8f6fd174b6505fcf33712b5">mathx::linsolv::matmul</a></div><div class="ttdeci">matrix&lt; T &gt; matmul(matrix&lt; T &gt; &amp;A, matrix&lt; T &gt; &amp;B)</div><div class="ttdoc">Multiply two matrices. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:79</div></div>
<div class="ttc" id="a00035_html_aff3710b9ff0307e61d21b74753731052"><div class="ttname"><a href="a00035.html#aff3710b9ff0307e61d21b74753731052">mathx::linsolv::qr_factorization_mgs</a></div><div class="ttdeci">matrix&lt; T &gt; qr_factorization_mgs(matrix&lt; T &gt; &amp;A)</div><div class="ttdoc">Decompose A into QR (where R = (Q^T)A) using MGS. </div><div class="ttdef"><b>Definition:</b> linsolv.hpp:283</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00033.html">mathx</a></li><li class="navelem"><a class="el" href="a00035.html">linsolv</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
