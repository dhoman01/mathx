<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Mathx Documentation: mathx::roots Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mathx Documentation
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Mathx is a software project that aims to solve computational mathematical problems.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('a00036.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mathx::roots Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0ad3d9468d2ffcc064626e16a1c531b1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a0ad3d9468d2ffcc064626e16a1c531b1">bisect</a> (<a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a> f, double a, double b, double fa, double fb, double tol, uint max)</td></tr>
<tr class="memdesc:a0ad3d9468d2ffcc064626e16a1c531b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds roots of a polynomial in range [a,b] using bisection.  <a href="#a0ad3d9468d2ffcc064626e16a1c531b1">More...</a><br /></td></tr>
<tr class="separator:a0ad3d9468d2ffcc064626e16a1c531b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e52bfec73bd0b5b8bd460a7690d9db1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a5e52bfec73bd0b5b8bd460a7690d9db1">fixed_point_iter</a> (<a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a> g, <a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a> f, double x0, double tol, uint max)</td></tr>
<tr class="memdesc:a5e52bfec73bd0b5b8bd460a7690d9db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a polynomial's roots using fixed point iteration.  <a href="#a5e52bfec73bd0b5b8bd460a7690d9db1">More...</a><br /></td></tr>
<tr class="separator:a5e52bfec73bd0b5b8bd460a7690d9db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915da811ff838b947a4977fbccd334ae"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a915da811ff838b947a4977fbccd334ae">newtons_method</a> (<a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a> f, <a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a> df, double x0, double tol, uint max)</td></tr>
<tr class="memdesc:a915da811ff838b947a4977fbccd334ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a polynomial's roots using Netwon's method.  <a href="#a915da811ff838b947a4977fbccd334ae">More...</a><br /></td></tr>
<tr class="separator:a915da811ff838b947a4977fbccd334ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90a50ce8388cdaf2f07093e5a50f5ac"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#ae90a50ce8388cdaf2f07093e5a50f5ac">secant_method</a> (<a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a> f, double x0, double x1, double tol, uint max)</td></tr>
<tr class="memdesc:ae90a50ce8388cdaf2f07093e5a50f5ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a polynomial's roots using the Secant method (variant of Netwon's method)  <a href="#ae90a50ce8388cdaf2f07093e5a50f5ac">More...</a><br /></td></tr>
<tr class="separator:ae90a50ce8388cdaf2f07093e5a50f5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c721b22f2adabb2bee78dacfadc59c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00036.html#a72c721b22f2adabb2bee78dacfadc59c">hybrid_method</a> (<a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a> f, double a, double b, double tol, uint max)</td></tr>
<tr class="memdesc:a72c721b22f2adabb2bee78dacfadc59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A globalization of the Secant method, using bisection to get a better guess.  <a href="#a72c721b22f2adabb2bee78dacfadc59c">More...</a><br /></td></tr>
<tr class="separator:a72c721b22f2adabb2bee78dacfadc59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contians functions used to find roots of functions.<br />
<br />
Beginning with the bisection method, bisection is a robust algorithm as the only condition for convergence is that the function changes signs on the interval <img class="formulaInl" alt="$[a,b]$" src="form_52.png"/>. Bisection is a <img class="formulaInl" alt="$O(n)$" src="form_73.png"/> method in converenge.<br />
<br />
Fixed point iteration (or functional iteration) does not need a bracketing interval. However, it does need a guess that is "sufficiently" close enough to the root and has some restrictions on <img class="formulaInl" alt="$f$" src="form_17.png"/>. For fixed point iteration to converge there must exist some <img class="formulaInl" alt="$g\in C[a,b]$" src="form_74.png"/> with <img class="formulaInl" alt="$a\leq g(x)\leq b$" src="form_75.png"/> for all <img class="formulaInl" alt="$x\in [a,b]$" src="form_76.png"/>. This implies that there is a fixed point <img class="formulaInl" alt="$x^{*}$" src="form_77.png"/> in the interval <img class="formulaInl" alt="$[a,b]$" src="form_52.png"/>. If, in addition, the derivative of <img class="formulaInl" alt="$g$" src="form_78.png"/> exists and there is a constant <img class="formulaInl" alt="$\rho&lt;1$" src="form_79.png"/> such that </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[|g'(x)|\leq \rho\quad\quad\textrm{for all }x\in [a,b],\]" src="form_80.png"/>
</p>
<p> then the fixed point is unique <a class="el" href="a00042.html#CITEREF_AscherGrief">[1]</a> Fixed Point iteration's rate of convergence is dependant on the choice of <img class="formulaInl" alt="$g(x)$" src="form_9.png"/>.<br />
<br />
Newton's method restricts <img class="formulaInl" alt="$f$" src="form_17.png"/> to the set <img class="formulaInl" alt="$C^2[a,b]$" src="form_15.png"/> and defines </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[x_{k+1}=x_k-\frac{f(x_k)}{f'(x_k)}.\]" src="form_81.png"/>
</p>
<p>. Newton's method is <img class="formulaInl" alt="$O(n^2)$" src="form_82.png"/>. Some downsides of Newton's methods are that the derivative must exist and you must know how to evaluate it and you must also know the local nature of the method's convergence <a class="el" href="a00042.html#CITEREF_AscherGrief">[1]</a><br />
<br />
The Secant method addresses the disadvantage of Newton's method requiring the derivative. This is accomplished by replacing <img class="formulaInl" alt="$f'$" src="form_23.png"/> with its finite difference approximation </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[f'(x_k)\approx \frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}.\]" src="form_83.png"/>
</p>
<p>. The secant method converges superlinearly.<br />
<br />
As both Newton's method and the Secant method require a guess that is "sufficiently" close to the root, where "sufficiently" is problem dependant, a naive approach would be to combine two methods. The hybrid method, or globalization of the Secant method, attempts to find a root on the interval <img class="formulaInl" alt="$[a,b]$" src="form_52.png"/> using the bisection method. The method will run for a few iterations thus reducing the size of the interval. After a few iterations, the Secant method will be attempted, using <img class="formulaInl" alt="$a$" src="form_84.png"/> and <img class="formulaInl" alt="$b$" src="form_85.png"/> from bisection as the initial guesses, and will continue as long as it is making improvement that is better than bisection ( <img class="formulaInl" alt="$|f_{k+1}|&lt;0.5|f_k|$" src="form_86.png"/>). This globalization of the Secant method alleviates the need to have knowledge of the local nature of the method's convergence. A similar method could be written for globalizing Newton's method. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a0ad3d9468d2ffcc064626e16a1c531b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mathx::roots::bisect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds roots of a polynomial in range [a,b] using bisection. </p>
<p>The bisection method requires a continuous function on the interval of [a,b], with <img class="formulaInl" alt="$f(a)\cdot f(b)&lt;0$" src="form_0.png"/>. Bisection will find the root by taking the midpoint, c, between a and b and evaluating if <img class="formulaInl" alt="$f(a)\cdot f(c)&lt;0$" src="form_1.png"/> OR <img class="formulaInl" alt="$f(b)\cdot f(c)&lt;0$" src="form_2.png"/>. With c becoming the new b or a, respectivally. Linear error convergence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>A continuous function. Data type double(double). See mathx::typedef function. </td></tr>
    <tr><td class="paramname">a</td><td>- a point at which <img class="formulaInl" alt="$f(a) &lt; 0$" src="form_3.png"/> </td></tr>
    <tr><td class="paramname">b</td><td>- a point at which <img class="formulaInl" alt="$f(b) &gt; 0$" src="form_4.png"/> and <img class="formulaInl" alt="$a&lt;b$" src="form_5.png"/> </td></tr>
    <tr><td class="paramname">fa</td><td>- <img class="formulaInl" alt="$f(a)$" src="form_6.png"/>. Used for convience to reduce the number of evaluations </td></tr>
    <tr><td class="paramname">fb</td><td>- <img class="formulaInl" alt="$f(b)$" src="form_7.png"/>. Used for convience to reduce the number of evaluations </td></tr>
    <tr><td class="paramname">tol</td><td>- the tolerance between a and b. Must be smaller than <img class="formulaInl" alt="$b_{initial}-a_{initial}$" src="form_8.png"/> </td></tr>
    <tr><td class="paramname">max</td><td>- maximum iterations the algorithm is allowed to execute. Used to prevent infinite loops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r - a root of the function <img class="formulaInl" alt="$f$" src="form_17.png"/> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00012.html#a1">roots.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;                                                                                             {</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;      <span class="comment">// Ensure parameters lead to valid problem</span></div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;      <span class="keywordflow">if</span>(a == b || fa * fb &gt; 0 || tol &lt;= 0) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;check your parameters&quot;</span>);</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;      <span class="comment">// Check if a or b are roots</span></div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;      <span class="keywordflow">if</span>(fa * fb == 0){</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        <span class="keywordflow">if</span>(fa == 0) <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;        <span class="keywordflow">if</span>(fb == 0) <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;      }</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;      <span class="comment">// If user inputs a &gt; b</span></div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;      <span class="comment">// swap a and b, fa and fb</span></div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;      <span class="keywordflow">if</span>(a &gt; b) {</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        std::swap(a, b);</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;        std::swap(fa, fb);</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;      }</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      <span class="comment">// Work loop</span></div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;      <span class="keywordtype">double</span> c = std::nan(<span class="stringliteral">&quot;1&quot;</span>);</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;      <span class="keywordflow">for</span>(uint k = 0; k &lt;= max &amp;&amp; std::abs(b - a) &gt; tol; k++){</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        c = (a + b) / 2;   <span class="comment">// Assign c to be midpoint of a and b</span></div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;        <span class="keywordtype">double</span> fc = f(c);</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;        <span class="keywordflow">if</span>(fa * fc &lt; 0){   <span class="comment">// If fa*fc &lt; 0 then the root is in [a,c]</span></div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;          b = c;           <span class="comment">// c becomes new b</span></div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;          fb = fc;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;        } <span class="keywordflow">else</span> {           <span class="comment">// else fb*fc &lt; 0 and the root is in [c,b]</span></div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;          a = c;           <span class="comment">// c becomes new a</span></div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;          fa = fc;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;        }</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;      }</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;      <span class="comment">// Either the tolerance or max</span></div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;      <span class="comment">// iterations were exceeded, return c</span></div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="comment">// If |b-a| &lt; tol then c is an</span></div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      <span class="comment">// approximation of the root</span></div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      <span class="keywordflow">return</span> c;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5e52bfec73bd0b5b8bd460a7690d9db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mathx::roots::fixed_point_iter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a>&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a polynomial's roots using fixed point iteration. </p>
<p>Fixed point iteration requires a continuous function and an initial guess sufficiently close to the root. Using <img class="formulaInl" alt="$g(x)$" src="form_9.png"/>, a function that <img class="formulaInl" alt="$x$" src="form_10.png"/> is equal to, the algorithm finds the root by evaluating a sequence of itearees. Linear error convergence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">g</td><td>- A function derived from f, such that <img class="formulaInl" alt="$x=g(x)$" src="form_11.png"/>. Data type double(double). See mathx::typedef function. </td></tr>
    <tr><td class="paramname">f</td><td>- A continuous function. Data type double(double). See mathx::typedef function. </td></tr>
    <tr><td class="paramname">x0</td><td>- An initial guess of the root of f. </td></tr>
    <tr><td class="paramname">tol</td><td>- the tolerance between a and b. Must be greater than 0 </td></tr>
    <tr><td class="paramname">max</td><td>- maximum iterations the algorithm is allowed to execute. Used to prevent infinite loops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r - a root of the function <img class="formulaInl" alt="$f$" src="form_17.png"/> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00012.html#a2">roots.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;                                                                                    {</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;      <span class="comment">// Ensure tolerance is valid</span></div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;      <span class="keywordflow">if</span>(tol &lt; 0) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;check your parameters&quot;</span>);</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;      <span class="keywordtype">double</span> xk = x0 - 1; <span class="comment">// Initialize xk to be used in calculating error</span></div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;      <span class="comment">// Work loop</span></div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;      <span class="keywordflow">for</span>(uint k = 0; k &lt; max &amp;&amp; std::abs(x0 - xk) &gt; tol; k++){</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;        xk = x0;     <span class="comment">// Store the x_k iteration</span></div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;        x0 = g(x0);  <span class="comment">// Caclulate x_{k+1}</span></div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;      }</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;      <span class="comment">// Either the tolerance or max</span></div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;      <span class="comment">// iterations were exceeded, return x0</span></div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;      <span class="comment">// If |x0-xk| &lt; tol then x0 is an</span></div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;      <span class="comment">// approximation of the root</span></div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;      <span class="keywordflow">if</span>(std::abs(x0 - xk) &gt; tol) <span class="keywordflow">return</span> std::nan(<span class="stringliteral">&quot;1&quot;</span>);</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;      <span class="keywordflow">return</span> x0;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a915da811ff838b947a4977fbccd334ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mathx::roots::newtons_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a>&#160;</td>
          <td class="paramname"><em>df</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a polynomial's roots using Netwon's method. </p>
<p>Newton's method is an iterative method used to find roots. Newton's method requires that <img class="formulaInl" alt="$f\in C^2[a,b]$" src="form_12.png"/>. Also the <img class="formulaInl" alt="$k+1$" src="form_13.png"/> iterate is calculated by: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[x_k-\frac{f(x_k)}{f'(x_k)}, k=0,1,2,\cdots\]" src="form_14.png"/>
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- a function in <img class="formulaInl" alt="$C^2[a,b]$" src="form_15.png"/>. Data type double(double). See mathx::typedef function. </td></tr>
    <tr><td class="paramname">df</td><td>- the derivative of f. Data type double(double). See mathx::typedef function. </td></tr>
    <tr><td class="paramname">x0</td><td>- an initial guess of the root </td></tr>
    <tr><td class="paramname">tol</td><td>- the tolerance between a and b. Must be greater than 0 </td></tr>
    <tr><td class="paramname">max</td><td>- maximum iterations the algorithm is allowed to execute. Used to prevent infinite loops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r - a root of the function <img class="formulaInl" alt="$f$" src="form_17.png"/> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00012.html#a3">roots.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                                                                                   {</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;      <span class="comment">// Check if guess is root</span></div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;      <span class="keywordflow">if</span>(f(x0) == 0) <span class="keywordflow">return</span> x0;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      <span class="comment">// Ensure valid problem</span></div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;      <span class="keywordflow">if</span>(tol &lt; 0 || df(x0) == 0) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;check your parameters&quot;</span>);</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      <span class="comment">// Initialize xk to be used in error calculation</span></div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;      <span class="keywordtype">double</span> xk = x0 - 1;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;      <span class="comment">// Work loop</span></div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;      <span class="keywordflow">for</span>(uint k = 0; k &lt; max &amp;&amp; std::abs(x0 - xk) &gt; tol; k++){</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;        xk = x0;                <span class="comment">// Store x_k</span></div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;        <span class="keywordtype">double</span> fk = f(xk);</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;        <span class="keywordtype">double</span> dfk = df(xk);</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;        <span class="comment">// If xk is a root return</span></div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;        <span class="keywordflow">if</span>(fk == 0) <span class="keywordflow">return</span> xk;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;        <span class="comment">// If the derivative equals 0 retrun NaN</span></div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;        <span class="keywordflow">if</span>(dfk == 0) <span class="keywordflow">return</span> std::nan(<span class="stringliteral">&quot;0&quot;</span>);</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;        x0 = xk - fk / dfk; <span class="comment">// Store x_{k+1}</span></div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;      }</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;      <span class="comment">// Either the tolerance or max</span></div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;      <span class="comment">// iterations were exceeded, return x0</span></div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      <span class="comment">// If |x0-xk| &lt; tol then x0 is an</span></div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;      <span class="comment">// approximation of the root</span></div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <span class="keywordflow">return</span> x0;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae90a50ce8388cdaf2f07093e5a50f5ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mathx::roots::secant_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a polynomial's roots using the Secant method (variant of Netwon's method) </p>
<p>A variation of Netwon's Method, the Secant method eliviates the need for the user to provide the derivative of f. The Secant method does this by approximating the <img class="formulaInl" alt="$k+1$" src="form_13.png"/> iterate by: </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[x_{k+1}=x_k-\frac{f(x_k)(x_k-x_{k-1})}{f(x_k)-f(x_{k-1})}, k=0,1,2,\cdots \]" src="form_16.png"/>
</p>
<p> However, the user must provide to guesses of the root </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- a function in <img class="formulaInl" alt="$C^2[a,b]$" src="form_15.png"/>. Data type double(double). See mathx::typedef function. </td></tr>
    <tr><td class="paramname">x0</td><td>- an initial guess of the root </td></tr>
    <tr><td class="paramname">x1</td><td>- an second guess of the root </td></tr>
    <tr><td class="paramname">tol</td><td>- the tolerance between a and b. Must be greater than 0 </td></tr>
    <tr><td class="paramname">max</td><td>- maximum iterations the algorithm is allowed to execute. Used to prevent infinite loops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r - a root of the function <img class="formulaInl" alt="$f$" src="form_17.png"/> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00012.html#a4">roots.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;                                                                                {</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;      <span class="comment">// Initialize f_k and f_{k+1}</span></div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;      <span class="keywordtype">double</span> fk = f(x0);</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;      <span class="keywordtype">double</span> fk_1 = f(x1);</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;      <span class="comment">// test if either guess is root</span></div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;      <span class="keywordflow">if</span>(fk == 0) <span class="keywordflow">return</span> x0;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;      <span class="keywordflow">if</span>(fk_1 == 0) <span class="keywordflow">return</span> x1;</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;      <span class="comment">// Ensure tolerance is valid</span></div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;      <span class="keywordflow">if</span>(tol &lt; 0) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;check your parameters&quot;</span>);</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;      <span class="comment">// Work loop</span></div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;      <span class="keywordflow">for</span>(uint k = 0; k &lt; max &amp;&amp; std::abs(x0 - x1) &gt; tol; k++){</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;        <span class="keywordtype">double</span> tmp = x0;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;        x0 = x0 -( ( fk * ( x0 - x1 ) ) / ( fk - fk_1 ) );    <span class="comment">// Caclulate x_{k+1}</span></div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;        x1 = tmp;                                             <span class="comment">// Store x_k</span></div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;        fk_1 = fk;</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;        fk = f(x0);</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;      }</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      <span class="comment">// Either the tolerance or max</span></div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      <span class="comment">// iterations were exceeded, return x0</span></div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;      <span class="comment">// If |x0-x1| &lt; tol then x0 is an</span></div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;      <span class="comment">// approximation of the root</span></div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;      <span class="keywordflow">return</span> x0;</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a72c721b22f2adabb2bee78dacfadc59c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mathx::roots::hybrid_method </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00033.html#a512b1b988583f98a80ad1f83ff8af3a2">function</a>&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A globalization of the Secant method, using bisection to get a better guess. </p>
<p>The Secant method requires two initial guesses sufficiently close to the root. Whereas bisection just requires that <img class="formulaInl" alt="$f$" src="form_17.png"/> changes signs on <img class="formulaInl" alt="$[a,b]$" src="form_52.png"/>. Thus we can use bisection to arrive at a better guesses for the Secant method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>- a function in <img class="formulaInl" alt="$C^2[a,b]$" src="form_15.png"/>. Data type double(double). See mathx::typedef function. </td></tr>
    <tr><td class="paramname">a</td><td>- a point at which <img class="formulaInl" alt="$f(a) &lt; 0$" src="form_3.png"/> </td></tr>
    <tr><td class="paramname">b</td><td>- a point at which <img class="formulaInl" alt="$f(b) &gt; 0$" src="form_4.png"/> and <img class="formulaInl" alt="$a&lt;b$" src="form_5.png"/> </td></tr>
    <tr><td class="paramname">tol</td><td>- the tolerance between a and b. Must be greater than 0 </td></tr>
    <tr><td class="paramname">max</td><td>- maximum iterations the algorithm is allowed to execute. Used to prevent infinite loops </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>r - a root of the function <img class="formulaInl" alt="$f$" src="form_17.png"/> </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="a00012.html#a5">roots.cpp</a>.</dd>
</dl><div class="fragment"><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;                                                                              {</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;      <span class="comment">// Ensure parameters lead to valid problem</span></div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;      <span class="keywordflow">if</span>(a == b || tol &lt;= 0) <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;check your parameters&quot;</span>);</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;      <span class="comment">// Initialize variables</span></div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      <span class="keywordtype">double</span> fa = f(a);</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;      <span class="keywordtype">double</span> fb = f(b);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;      <span class="comment">// Check if a or b are roots</span></div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;      <span class="keywordflow">if</span>(fa * fb == 0){</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;        <span class="keywordflow">if</span>(fa == 0) <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <span class="keywordflow">if</span>(fb == 0) <span class="keywordflow">return</span> a;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;      }</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;      <span class="comment">// If user inputs a &gt; b</span></div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;      <span class="comment">// swap a and b, fa and fb</span></div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;      <span class="keywordflow">if</span>(a &gt; b) {</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;        std::swap(a, b);</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;        std::swap(fa, fb);</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;      }</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;      <span class="keywordtype">double</span> c = std::nan(<span class="stringliteral">&quot;1&quot;</span>);</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;      <span class="comment">// Work loop</span></div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;      <span class="comment">// Do five steps of bisection</span></div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;      <span class="comment">// Then try Secant method until</span></div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;      <span class="comment">// one of the following:</span></div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;      <span class="comment">//   1. Max iter reached</span></div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      <span class="comment">//   2. Tolerance exceeded</span></div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      <span class="comment">//   3. Convergence is not optimal (|fkp1|&lt;0.5|fk|)</span></div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;      <span class="keywordflow">for</span>(uint k = 0; k &lt;= max &amp;&amp; std::abs(b - a) &gt; tol; k++){</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;        c = (a + b) / 2;   <span class="comment">// Assign c to be midpoint of a and b</span></div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;        <span class="keywordtype">double</span> fc = f(c);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;        <span class="comment">// Reinitialize variables</span></div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;        <span class="keywordflow">if</span>(fa * fc &lt; 0){   <span class="comment">// If fa*fc &lt; 0 then the root is in [a,c]</span></div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;          b = c;           <span class="comment">// c becomes new b</span></div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;          fb = fc;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;        } <span class="keywordflow">else</span> {           <span class="comment">// else fb*fc &lt; 0 and the root is in [c,b]</span></div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;          a = c;           <span class="comment">// c becomes new a</span></div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;          fa = fc;</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;        }</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;        <span class="comment">// Try the Secant method on 5</span></div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <span class="comment">// iteration intervals</span></div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">if</span>(k % 5 == 0 &amp;&amp; k != 0){</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;          <span class="keywordtype">double</span> x0 = a;</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;          <span class="keywordtype">double</span> x1 = b;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;          <span class="comment">// Initialize f_k and f_{k+1}</span></div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;          <span class="keywordtype">double</span> fk = f(x0);</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;          <span class="keywordtype">double</span> fk_1 = f(x1);</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;          <span class="comment">// test if either guess is root</span></div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;          <span class="keywordflow">if</span>(fk == 0) <span class="keywordflow">return</span> x0;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;          <span class="keywordflow">if</span>(fk_1 == 0) <span class="keywordflow">return</span> x1;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;          <span class="comment">// Work loop</span></div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;          <span class="keywordflow">for</span>(uint n = 0; n &lt; max &amp;&amp; std::abs(x0 - x1) &gt; tol &amp;&amp; std::abs(fk) &lt; 0.5 * std::abs(fk_1); n++){</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;            <span class="keywordtype">double</span> tmp = x0;</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;            x0 = x0 -( (fk * ( x0 - x1 ) ) / ( fk - fk_1 ) );    <span class="comment">// Caclulate x_{k+1}</span></div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;            x1 = tmp;                                            <span class="comment">// Store x_k</span></div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;            fk_1 = fk;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;            fk = f(x0);</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;          }</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;          <span class="comment">// The tolerance was exceeded</span></div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;          <span class="keywordflow">if</span>(std::abs(x0 - x1) &lt; tol)</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;            <span class="keywordflow">return</span> x0;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;        }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;      }</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;      <span class="comment">// Either the tolerance or max</span></div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;      <span class="comment">// iterations were exceeded, return c</span></div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;      <span class="comment">// If |b-a| &lt; tol then c is an</span></div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;      <span class="comment">// approximation of the root</span></div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;      <span class="keywordflow">return</span> c;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="a00033.html">mathx</a></li><li class="navelem"><a class="el" href="a00036.html">roots</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
